# Testing en Angular

- [Testing en Angular](#testing-en-angular)
  - [_Re-configuración del entorno de test_](#re-configuración-del-entorno-de-test)
  - [Elementos iniciales](#elementos-iniciales)
  - [Tests iniciales](#tests-iniciales)
    - [Test del componente Header: Test de comportamiento](#test-del-componente-header-test-de-comportamiento)
      - [Test del componente Menu: Test de implementación](#test-del-componente-menu-test-de-implementación)
    - [Test del componente Counter: eventos y funcionalidad](#test-del-componente-counter-eventos-y-funcionalidad)
    - [Test del componente Greeting: two-way data binding](#test-del-componente-greeting-two-way-data-binding)
    - [Test del componente Layout: proyección de contenido](#test-del-componente-layout-proyección-de-contenido)
    - [Test con carga de datos](#test-con-carga-de-datos)
  - [Comunicación de componentes](#comunicación-de-componentes)
    - [Inputs: propiedades del padre](#inputs-propiedades-del-padre)
      - [Test del componente Menu](#test-del-componente-menu)
      - [Testing de los componentes Header (y Footer)](#testing-de-los-componentes-header-y-footer)
    - [ClickersContainer: Outputs: eventos hacia el padre](#clickerscontainer-outputs-eventos-hacia-el-padre)
      - [Test del componente ClickersContainer](#test-del-componente-clickerscontainer)
      - [Test del componente Click. SpyOn en Jasmine](#test-del-componente-click-spyon-en-jasmine)
    - [Design System: componente Input propio](#design-system-componente-input-propio)
    - [Creación del componente Input](#creación-del-componente-input)
      - [_Testing del Componente input_](#testing-del-componente-input)
  - [Arquitectura básica: controlador (contenedor) /presentadores](#arquitectura-básica-controlador-contenedor-presentadores)
    - [Test del componente noteAdd](#test-del-componente-noteadd)
    - [Test del componente noteCard](#test-del-componente-notecard)
    - [Problemas en el orden de los test](#problemas-en-el-orden-de-los-test)
    - [Test del componente noteList](#test-del-componente-notelist)
  - [Servicios: InMemoryRepo](#servicios-inmemoryrepo)
    - [Test del componente](#test-del-componente)
    - [Test del servicio](#test-del-servicio)
  - [Servicios: Storage parametrizado](#servicios-storage-parametrizado)
    - [Test del servicio usando un Factory](#test-del-servicio-usando-un-factory)
    - [Test del servicio definiendo un provider](#test-del-servicio-definiendo-un-provider)
  - [Servicios: LocalRepo](#servicios-localrepo)
    - [Test usando prototipos](#test-usando-prototipos)
    - [Test inyectando un mock](#test-inyectando-un-mock)
    - [Test del componente CoursesList, que utiliza el servicio LocalRepo](#test-del-componente-courseslist-que-utiliza-el-servicio-localrepo)
  - [Servicios: LocalRepo utilizando observables](#servicios-localrepo-utilizando-observables)
    - [Ajustes de los tests del repo al uso de observables](#ajustes-de-los-tests-del-repo-al-uso-de-observables)
    - [Ajustes de los tests del componente al uso de observables](#ajustes-de-los-tests-del-componente-al-uso-de-observables)
  - [Formularios reactivos](#formularios-reactivos)
    - [Test de los formularios Data-Driven (Login y Register)](#test-de-los-formularios-data-driven-login-y-register)
  - [HttpClient](#httpclient)
    - [Test del servicio con HttpClient](#test-del-servicio-con-httpclient)
    - [Ajustes en los tests de componentes al usar HttpClient en sus servicios](#ajustes-en-los-tests-de-componentes-al-usar-httpclient-en-sus-servicios)
  - [Gestión de Estados: Flux](#gestión-de-estados-flux)
    - [Test del servicio con estado](#test-del-servicio-con-estado)
    - [Test de los componentes que utilizan el servicio](#test-de-los-componentes-que-utilizan-el-servicio)
    - [Test del interceptor de errores](#test-del-interceptor-de-errores)
  - [Signals](#signals)
    - [Test del servicio con estado basado en signals](#test-del-servicio-con-estado-basado-en-signals)
    - [Tests de los componentes que usan el servicio basado en signals](#tests-de-los-componentes-que-usan-el-servicio-basado-en-signals)

## _Re-configuración del entorno de test_

```shell
npm i -D karma-mocha-reporter
ng g config karma
```

Crea el fichero de configuración y lo referencia en angular.json

```shell
CREATE projects/demo/karma.conf.js (1356 bytes)
UPDATE angular.json (4561 bytes)
```

```json
    "projects": {
      "demo": {
        "root": "projects/demo",
        "sourceRoot": "projects/demo/src",
        "projectType": "library",
        "architect": {
          "build": {
            //...
            "configurations": {
              //...
              "test": {
                "karmaConfig": "./karma.conf.js"
              }
            }
          }
        }
      },
```

Configuración de karma: projects/demo/karma.conf.js (1356 bytes)

```js
  plugins: [
      // ...
      require("karma-mocha-reporter"),
      require("@angular-devkit/build-angular/plugins/karma"),
    ],


    coverageReporter: {
      //...
      reporters: [{ type: "lcov" }, { type: "text" }],
    },
    reporters: ["mocha", "kjhtml"],
    //...

```

script de ejecución del test

```json
    "test": "ng test --code-coverage --browsers=ChromeHeadless",
    "test:prod": "ng test --code-coverage --no-watch --browsers=ChromeHeadless",
```

Nuestro entrono de test es ahora similar al de Jest que ya conocemos

```shell
✔ Browser application bundle generation complete.
10 01 2024 19:27:41.353:WARN [karma]: No captured browser, open http://localhost:9876/
10 01 2024 19:27:41.370:INFO [karma-server]: Karma v6.4.2 server started at http://localhost:9876/
10 01 2024 19:27:41.370:INFO [launcher]: Launching browsers ChromeHeadless with concurrency unlimited
10 01 2024 19:27:41.380:INFO [launcher]: Starting browser ChromeHeadless
10 01 2024 19:27:42.165:INFO [Chrome Headless 120.0.6099.216 (Windows 10)]: Connected on socket 8CaGnX-85MTwA1diAAAB with id 93006915

START:
  SampleComponent
    √ should have the 'demo' title
    √ should render title
    √ should create
  AppComponent
    √ should create the app

Finished in 0.049 secs / 0.045 secs @ 19:27:43 GMT+0100 (hora estándar de Europa central)

SUMMARY:
√ 4 tests completed
-----------------------|---------|----------|---------|---------|-------------------
File                   | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s
-----------------------|---------|----------|---------|---------|-------------------
All files              |     100 |      100 |     100 |     100 |
 app                   |     100 |      100 |     100 |     100 |
  app.component.ts     |     100 |      100 |     100 |     100 |
 app/components/sample |     100 |      100 |     100 |     100 |
  sample.component.ts  |     100 |      100 |     100 |     100 |
-----------------------|---------|----------|---------|---------|-------------------
```

## Elementos iniciales

- Componentes tipo página: Home, About...
- Rutas
- Menu de Navegación
- Componentes Header y Footer
- Componente Contador: estado y eventos
- Componente saludo: two-way data binding (ngModel)
- Componente Layout: proyección de contenido
- Componente Logo: uso de SVG; proyección de contenido múltiple

## Tests iniciales

### Test del componente Header: Test de comportamiento

Un componente sin lógica, con el test "de huno" que implementa el CLI de Angular ya tiene un 100% de coverage. Por supuesto, no es suficiente para un componente real.

```ts
it("should create", () => {
  expect(component).toBeTruthy();
});
```

Deberíamos testar ue renderiza realmente lo esperado.

- Añadimos el debugElement a partir de la fixture
- Buscamos él con el selector de la etiqueta p
- Nos quedamos con el correspondiente nativeElement
- Comprobamos que contiene el texto esperado

```ts
it("should render a paragraph", () => {
  let h1Element: HTMLParagraphElement = debugElement.query(By.css("h1")).nativeElement;
  expect(h1Element.textContent).toContain("Demo App");
});
```

#### Test del componente Menu: Test de implementación

A diferencia de lo que sucede en Testing Library, tenemos acceso a las propiedades de la instancia.
Por ejemplo podríamos añadir una nueva opción al menu y comprobar que se renderiza

```ts
it("should render a menu item", () => {
  component.options.push({
    path: "Test",
    label: "Test",
  });
  fixture.detectChanges();
  let itemElement: HTMLLiElement = debugElement.queryAll(By.css("li"))[2].nativeElement;
  expect(itemElement.textContent).toContain("Test");
});
```

### Test del componente Counter: eventos y funcionalidad

Como tenemos botones, debemos comprobar su funcionalidad.

El debugElement dispone para es del método triggerEventHandler() para disparar el click del botón.
Después de usarlo es importante lanzar **fixture.detectChanges()** para que la vista refleje los cambios en el componente. El proceso de detección del cambio automático en los componentes de Angular no lo es en el entorno de test, por lo que hay que ejecutar el correspondiente método de la fixture

```ts
describe("When we use the buttons", () => {
  let spanElement: HTMLSpanElement;
  let buttonDebugElements: DebugElement[];
  beforeEach(() => {
    spanElement = debugElement.query(By.css("span")).nativeElement;
    buttonDebugElements = debugElement.queryAll(By.css("button"));
  });

  it("should increase the display when the button + is clicked", () => {
    component.counter = 0;
    buttonDebugElements[1].triggerEventHandler("click");
    fixture.detectChanges();
    expect(spanElement.textContent).toBe("1");
  });

  it("should increase the display when the button + is clicked", () => {
    component.counter = 0;
    buttonDebugElements[0].triggerEventHandler("click");
    fixture.detectChanges();
    expect(spanElement.textContent).toBe("-1");
  });
});
```

### Test del componente Greeting: two-way data binding

Las responsabilidades de este componente son

- recoger el valor que escribe el usuario
- actualizar con el el estado del componente y reflejarlo en la vista
- responder al click en el botón modificando el estado y la vista

Para tester lo primero, accedemos al input, cambiamos su valor y despachamos un evento input.
De esa forma simulamos la interacción del usuario con el input
A continuación, tras lanzar la detección de cambios, comprobamos que la vista se ha actualizado.

Como ya vimos antes, disparamos el evento click del botón con el método triggerEventHandler del debugElement
y de nuevo, tras lanzar la detección de cambios, comprobamos que la vista se ha actualizado.

```ts
it("should type a user name and see in the document", () => {
  let inputElement: HTMLInputElement = debugElement.query(By.css(".user input")).nativeElement;
  inputElement.value = "Test";
  inputElement.dispatchEvent(new Event("input"));
  fixture.detectChanges();

  let pElement: HTMLParagraphElement = debugElement.query(By.css(".user p")).nativeElement;
  expect(pElement.textContent).toBe("Hola Test");

  let buttonDebugElement = debugElement.query(By.css(".user button"));
  buttonDebugElement.triggerEventHandler("click");
  fixture.detectChanges();
  expect(pElement.textContent).toBe("Hola amigo");
});
```

### Test del componente Layout: proyección de contenido

El componente Layout es un contenedor que proyecta el contenido de los componentes hijos. En este caso, el componente Layout tiene un slot para el header y otro para el footer.

Para testearlo, creamos un componente de prueba que contiene el Layout y los componentes Header y Footer.

```ts
@Component({
  selector: 'app-test-layout',
  template: `
    <app-layout>
      <h1>Demo App</h1>
      <p>Demo Footer</p>
    </app-layout>
  `,
}) class TestLayoutComponent {}

...

beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [TestLayoutComponent, LayoutComponent],
    });
    fixture = TestBed.createComponent(TestLayoutComponent);
    debugElement = fixture.debugElement.query(By.directive(LayoutComponent));
    component = debugElement.componentInstance;
    fixture.detectChanges();
  });

```

En el test, comprobamos que el contenido del header y footer se proyecta correctamente en el Layout.

```ts
it("should project the header and footer", () => {
  let headerElement: HTMLHeadingElement = debugElement.query(By.css("h1")).nativeElement;
  let footerElement: HTMLHeadingElement = debugElement.query(By.css("p")).nativeElement;
  expect(headerElement.textContent).toBe("Demo App");
  expect(footerElement.textContent).toBe("Demo Footer");
});
```

### Test con carga de datos

En el beforeAll inicial, tenemos que esperar de ngOnInit termine el proceso de carga asíncrona de los datos

```ts
beforeEach(async () => {
  await TestBed.configureTestingModule({
    imports: [TodoComponent],
  }).compileComponents();

  fixture = TestBed.createComponent(TodoComponent);
  component = fixture.componentInstance;
  debugElement = fixture.debugElement;
  fixture.detectChanges(); // dispara ngOnInit
  await fixture.whenStable();
  fixture.detectChanges();
});
```

## Comunicación de componentes

### Inputs: propiedades del padre

#### Test del componente Menu

Modificamos el componente Menu para que reciba las opciones como un input

```ts
  @Input() options: MenuOption[] = [];
```

En el test del componente que recibe valores en un atributo, podemos simularla asignándole un valor a la propiedad a través de la instancia del componente

```ts
component.options = [
  {
    path: "Test",
    label: "Test",
  },
];
```

#### Testing de los componentes Header (y Footer)

Modificamos el componente Header para que reciba el título como un input

```ts
  @Input() title: string = 'Demo App';
```

Añadimos el test que comprueba como efectivamente renderizan los valores que reciben en el input

```ts
describe("When the componente receive a title as input", () => {
  beforeEach(() => {
    component.title = "Testing title";
    fixture.detectChanges();
  });
  it("should be render the title", () => {
    const h1Element = fixture.debugElement.query(By.css("h1")).nativeElement as HTMLHeadingElement;
    expect(h1Element.textContent).toContain(component.title);
  });
});
```

### ClickersContainer: Outputs: eventos hacia el padre

El componente ClickersContainer es un contenedor que contiene varios contadores y totaliza el número de clicks y el valor total en el conjunto de ellos.

#### Test del componente ClickersContainer

Como la responsabilidad del componente es responder a los evento, podríamos testarlo de formo integrada con el componente que los emite, simulando los clicks en el componente hijo.

Otra alternativa más unitaria es acceder al debugElement del componente hijo
y emitir el evento en directamente con triggerEventHandler para en el expect comprobar la respuesta.

```ts
beforeEach(() => {
  const counterElement: DebugElement[] = debugElement.queryAll(By.css("isdi-counter"));
  counterElement[0].triggerEventHandler("countEvent", 10);
});

it("should respond to the event changing its values", () => {
  expect(component.clicks).toBe(1);
  expect(component.collected).toBe(10);
});
```

#### Test del componente Click. SpyOn en Jasmine

Aunque aparentemente continúa pasando el test, no estamos testando su nueva funcionalidad de emitir eventos.
Para ello creamos un Spy de jest para el método next de la propiedad eventEmitter del componente
y comprobamos que el método ha sido llamado con el valor correspondiente en cada caso

```ts
   spyOn(component.countEvent, 'next');
   ...
   // tras el click en un botón
    expect(component.countEvent.next).toHaveBeenCalledWith(1);
    ---
    // tras el click en el otro botón
    expect(component.countEvent.next).toHaveBeenCalledWith(-1);

```

Tal como lo estamos usando, el spy es en realidad un mock (como jest.fn) sin ninguna implementación.

Para que sea realmente un spy, manteniendo la implementación original, le añadimos el método callThrough

```ts
spyOn(component.countEvent, "next").and.callThrough();
```

### Design System: componente Input propio

### Creación del componente Input

El componente recibe como inputs el texto que presentara al usuario junto con el objeto donde guardará los datos y la clave concreta del objeto.

```ts
export class InputComponent {
  @Input({ required: true }) label!: string;
  @Input({ required: true }) modelData!: { [key: string]: string };
  @Input({ required: true }) modelKey!: string;
}
```

Al ser un objeto se puede guardar la información mutándolo, de forma que el nuevo valor se vea reflejado en el objeto original.

En el template, **ngModel** se vincula con la propiedad del objeto

```html
<label>
  <!-- Don`t remove placeholder: used by CSS implementation -->
  <input type="text" placeholder=" " [(ngModel)]="modelData[modelKey]" (focus)="handleFocus($event)" />
  <span>{{label}}</span>
</label>
```

Cuando el input recibe el foco re-emite el evento, con nuestro propio EventEmitter focusEvent, para al consumir nuestro componente se pueda reaccionar al evento focus en el input nativo de HTML

```ts
  @Output() focusEvent = new EventEmitter<Event>();
  ...
  handleFocus(event: Event) {
    this.focusEvent.next(event);
  }
```

#### _Testing del Componente input_

Similar al de inputs anteriores y a otros componentes con inputs.

Inicialmente comprobamos que se renderiza el valor recibido como input label

```ts
  component.label = 'Sample Value';
  ...
  const labelElement: HTMLLabelElement = fixture.debugElement.query(
    By.css('label')
  ).nativeElement;
  expect(labelElement.textContent).toBe('Sample Value');
```

Por otro lado, comprobando que el objeto recibido como input muta de acuerdo con los valores del input HTML

```ts
  const modelData = { sampleKey: '' };
  ...
  beforeEach(async () => {
    ...
    component.label = 'Sample Value';
    component.modelData = modelData;
    component.modelKey = 'sampleKey';
    ...
  });

  const inputElement: HTMLInputElement = fixture.debugElement.query(
    By.css('input')
  ).nativeElement;
  inputElement.value = 'Test';
  inputElement.dispatchEvent(new Event('input'));
  fixture.detectChanges();
  expect(modelData.sampleKey).toBe('Test');
```

Finalmente, respecto al event que hemos creado, comprobamos que se emite cuando el input nativo recibe el foco

```ts
spyOn(component.focusEvent, "next");
const inputElement: HTMLInputElement = fixture.debugElement.query(By.css("input")).nativeElement;
inputElement.dispatchEvent(new Event("focus"));
fixture.detectChanges();
expect(component.focusEvent.next).toHaveBeenCalled();
```

## Arquitectura básica: controlador (contenedor) /presentadores

El componente notesList es un contenedor que contiene los componentes presentadores **noteAdd** y **noteCard**. El primero se encarga de añadir notas y el segundo de mostrarlas y permitir su edición.

### Test del componente noteAdd

En el componente **noteAdd** el arrange es muy similar a la parte añadir del componente TODO List (all-in-one): simulamos escribir los inputs y pulsar el botón

Lo que cambia es el assert, ya que ahora espiamos el eventEmitter y comprobamos que ha sido llamado

```ts
spyOn(component.addEvent, "next");
expect(component.addEvent.next).toHaveBeenCalledWith(mockNoteData);
```

Testamos también el nuevo botón de cancelar, comprobando que resetea los valores de las propiedades del componente.

### Test del componente noteCard

En el componente **noteCard** el arrange vuelve a ser muy similar para los tres casos que testamos, y el expect en cada caso es que se haya disparado el evento que estaremos espiando

- When the user modify a note checking it for important

```ts
spyOn(component.updateEvent, "next");
expect(component.updateEvent.next).toHaveBeenCalledOnceWith({
  isImportant: true,
} as Note);
```

- When the user modify a note writing a new title

```ts
spyOn(component.updateEvent, "next");
expect(component.updateEvent.next).toHaveBeenCalledOnceWith({
  ...mockNote,
  title: "Updated title",
} as Note);
```

- When the user click de button for delete a note

```ts
spyOn(component.deleteEvent, "next");
component.item = { ...mockNote, id: "1" };
expect(component.deleteEvent.next).toHaveBeenCalledOnceWith({
  ...mockNote,
  id: "1",
});
```

Aunque ya lo hemos visto, recordemos que tal como lo estamos usando, el spy es en realidad un mock (como jest.fn) sin ninguna implementación.

Para que sea realmente un spy, manteniendo la implementación original, le añadimos el método callThrough

```ts
spyOn(component.deleteEvent, "next").and.callThrough();
```

### Problemas en el orden de los test

Para este caso concreto puede suceder que los test fallen aleatoriamente por el orden random en que Jasmine los ejecuta.

Puede modificarse este comportamiento en el fichero karma.conf.js

```js
 client: {
    jasmine: {
      // you can add configuration options for Jasmine here
      // the possible options are listed at https://jasmine.github.io/api/edge/Configuration.html
      // for example, you can disable the random execution with `random: false`
      // or set a specific seed with `seed: 4321`
      random: false,
    },
    ...
  },
```

### Test del componente noteList

En este caso, la funcionalidad del componente es responder a los eventos en los componentes hijos, por lo que en el test dispararemos esos eventos gracias al triggerEventHandler del debugElement, como vimos en el componente Clickers

When the component NoteAdd emit the event addEvent

```ts
component.notes = [{ id: "1" } as Note];
const addNoteElement: DebugElement = debugElement.query(By.css("isdi-note-add"));
addNoteElement.triggerEventHandler("addEvent", { id: 2 });

expect(component.notes.length).toBe(2);
```

When the component NoteCard emit the event updateEvent

```ts
component.notes = [{ id: "1" } as Note, { id: "2" } as Note];
fixture.detectChanges();
const cardNoteElement: DebugElement[] = debugElement.queryAll(By.css("isdi-note-card"));
cardNoteElement[0].triggerEventHandler("updateEvent", {
  id: "1",
  title: "Test",
} as Note);

expect(component.notes[0].title).toBe("Test");
```

When the component NoteCard emit the event deleteEvent

```ts
component.notes = [{ id: "1" } as Note];
fixture.detectChanges();
const cardNoteElement: DebugElement = debugElement.query(By.css("isdi-note-card"));
cardNoteElement.triggerEventHandler("deleteEvent", { id: "1" });

expect(component.notes.length).toBe(0);
```

## Servicios: InMemoryRepo

Creamos un servicio que simula un repositorio de cursos (RepoInMemory), con métodos para obtener, añadir y actualizar cursos. El servicio es asíncrono, por lo que los métodos devuelven promesas.

Testamos el servicio y del componente que lo usa

### Test del componente

La responsabilidad del **componente** es ahora invocar al servicio, y eso es lo que debemos testar, para lo cual tendremos que espiarlo/moquearlo

En lo que se refiere a los métodos podríamos hacerlo a traves del prototipo, y mediante callThrough dejamos que el servicio se ejecute realmente, es decir, lo espiamos pero no lo moqueamos.

Como todos los métodos del servicio son asíncronos, es necesario que el test lo sea y que ejecutemos fixture.whenStable(), similar al act que utilizamos en Jest.

```ts
spyOn(CoursesInMemoryRepoService.prototype, "add").and.callThrough();

await fixture.whenStable();
expect(CoursesInMemoryRepoService.prototype.add).toHaveBeenCalled();
expect(component.courses.length).toBe(2);
```

Una alternativa más integrada en Angular es

- convertir a nuestro entorno del test en el **provider** del servicio
- **inyectarlo** cuando se instancia el componente que estamos testando

```ts
  let service: CoursesInMemoryRepoService;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [CoursesListComponent],
      providers: [CoursesInMemoryRepoService],
    }).compileComponents();
    ...
    service = TestBed.inject(CoursesInMemoryRepoService);
    service.courses = [{ id: '1' } as Curse];
    fixture.detectChanges();
  });
```

De esta forma además conseguimos acceso no solo a los métodos del servicio, también a sus propiedades, que no están en el prototipo. Con ello podemos incluso ajustarlas para cada test

Al hacerlo así, la propiedad correspondiente a la inyección del servicio en el componente real puede ser **privada (private)** con lo que aplicamos buenas practicas de orientación a objetos para mejorar la encapsulación.

En consecuencia, espiamos directamente cada uno de los **métodos** de la propiedad service, correspondiente a la instancia del servicio que se inyectará en el componente

```ts
service.courses = [{ id: "1" } as Curse, { id: "2" } as Curse];
fixture.detectChanges();
spyOn(service, "update").and.callThrough();

await fixture.whenStable();
expect(service.update).toHaveBeenCalled();
expect(component.courses[0].title).toBe("Test");
```

En este caso, como el servicio solo almacena datos en memoria, no lo hemos moqueado, sino espiado, por lo queda testado al testar el componente que lo usa

### Test del servicio

Al margen de lo anterior, vamos a testar el propio servicio de forma unitaria.

Para ello basta inyectarlo en el entorno de test

```ts
let service: CoursesInMemoryRepoService;

TestBed.configureTestingModule({});
service = TestBed.inject(CoursesInMemoryRepoService);
```

Disponemos así de una instancia del servicio y podemos acceder a sus propiedades y métodos, ejecutando estos últimos para testarlos

```ts
service.courses = [];
async () => {
  const result = await service.getAll();
  expect(result).toEqual([]);
};
```

Como los métodos del servicio son asíncronos, también lo serán los tests

Lo mismo para el siguiente método

```ts
  service.courses = [];
  async () => {
      const result = await service.add({ id: '1' });
      expect(result).toEqual([{ id: '1', isComplete: false } as Course]);
    });
```

Y así en cada método

## Servicios: Storage parametrizado

Esta servicio almacena los datos en el localStorage del navegador, por lo que es necesario moquear el localStorage para evitar problemas de acceso a la API del navegador.

La principal novedad de este servicio es que si queremos que sea abstracto, necesitamos pasarle parámetros para indicarle

- el nombre del store
- si queremos que utilice localStore o sessionStore

Par ello los definimos en el constructor con el decorador @Inject() que le indica que los recibirá durante la inyección de dependencia

```ts
  constructor(
    @Inject('storeName') private storeName: string,
    @Inject('storeType') @Optional() private storeType?: string
  ) {
    this.storeType = storeType || 'local';
    this.storage = this.storeType === 'local' ? localStorage : sessionStorage;
  }
```

El resto del servicio se limita a encapsular los métodos de local/sessionStore recibiendo o devolviendo los datos de acuerdo con el tipo asignado en forma de genérico.

### Test del servicio usando un Factory

Para testar un servicio que recibe parámetros necesitamos inyectarle valores en dichos parámetros.

Podemos hacerlo gracias al inyector del entorno de testing TestBed.inject()

Los inyectores de Angular reciben desde el Provider un token que puede corresponder a distintas formas de crear el objeto que van a inyectar

- una clase que se instanciará [useClass - this option tells Angular DI to instantiate a provided class when a dependency is injected]
- un token ya existente [useExisting - allows you to alias a token and reference any existing one.]
- un factoría que devuelve la instancia [useFactory - allows you to define a function that constructs a dependency.]
- una constante [useValue - provides a static value that should be used as a dependency.]

En este caso usaremos un Token de tipo Factory, que nos permite ser nosotros lo que instanciamos la clase y así pasarle al constructor los parámetros adecuados.

```ts
  type Test = [];
  const storeName = 'Tasks';

  const STORAGE_TOKEN = new InjectionToken<StorageService<Test>>(
    'Storage Service',
    {
      providedIn: 'root',
      factory: () => new StorageService<Test>(storeName),
    }
  );

  let service: StorageService<Test>;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(STORAGE_TOKEN);
  });
  ...
```

### Test del servicio definiendo un provider

Una alternativa más próxima a la forma real en que usaremos el servicio, es definir su provider:

- en el entorno real sería el componente que consuma el servicio
- en los test será en TestBed

En ambos casos, además de provider del servicio, lo será de los tokens con sus parámetros, uno para el nombre del store (storeName) y, opcionalmente, otro token para el tipo de store (storeType)

```ts
TestBed.configureTestingModule({
  providers: [StorageService, { provide: "storeName", useValue: storeName }, { provide: "storeType", useValue: storeType }],
});
```

En cualquiera de los dos casos, los test en si son muy simples: ejecutan cada uno de los métodos del servicio habiendo moqueado localStore y en el assert se comprueba que recogen y procesan la respuesta del mock

- para el método get, con o sin datas en el store

```ts
spyOn(window.localStorage, "getItem");
service.get();
expect(window.localStorage.getItem).toHaveBeenCalled();

spyOn(window.localStorage, "getItem").and.returnValue("[]");
const result = service.get();
expect(result).toEqual([]);
```

- para el método set

```ts
spyOn(window.localStorage, "setItem");
service.set([]);
expect(window.localStorage.setItem).toHaveBeenCalled();
```

- para el método remove

```ts
spyOn(window.localStorage, "removeItem");
service.remove();
expect(window.localStorage.removeItem).toHaveBeenCalled();
```

## Servicios: LocalRepo

Esta nueva versión de repositorio almacena los datos en el localStorage pero no directamente, sino utilizando nuestro servicio Storage, que encapsula el localStorage, por lo que moquearemos el mencionado servicio Storage. Para simular un repositorio asíncrono, el servicio LocalRepo devuelve promesas.

Vamos a ver dos posibles enfoques, el primero basado en los prototipos de las clases de ES y el segundo en la forma en que trabajan los inyectores de dependencia de Angular

### Test usando prototipos

El servicio se incorpora al test en el injector del TestBed, tal como nos proporciona el CLI, añadiendo en el provider el token con los parámetros de StorageService

```ts
  providers: [
    StorageService,
    { provide: 'storeName', useValue: 'Courses' },
  ],
```

En el encontraremos inyectado el servicio StorageService que podemos moquear fácilmente a traves de su prototipo; con spyOn(...).and.returnValue(...) definiremos el comportamiento del mock cuando necesitemos que devuelva algún valor, adecuándolo a cada uno de los cuatro métodos que tenemos que testar

- getAll()

```ts
spyOn(StorageService.prototype, "get").and.returnValue([]);
const result = await service.getAll();
expect(StorageService.prototype.get).toHaveBeenCalled();
expect(result).toEqual([]);
```

- add()

```ts
spyOn(StorageService.prototype, "get").and.returnValue([]);
spyOn(StorageService.prototype, "set");
const result = await service.add({ id: "1" });
expect(StorageService.prototype.get).toHaveBeenCalled();
expect(StorageService.prototype.set).toHaveBeenCalled();
expect(result).toEqual([{ id: "1", isComplete: false } as Course]);
```

- update()

```ts
spyOn(StorageService.prototype, "get").and.returnValue([
  { id: "1", isComplete: false },
  { id: "2", isComplete: false },
]);
const result = await service.update("1", { id: "1", isComplete: true });
expect(StorageService.prototype.get).toHaveBeenCalled();
expect(StorageService.prototype.set).toHaveBeenCalled();
expect(result).toEqual([{ id: "1", isComplete: true } as Course, { id: "2", isComplete: false } as Course]);
```

- delete()

```ts
spyOn(StorageService.prototype, "get").and.returnValue([{ id: "1", isComplete: false }]);
spyOn(StorageService.prototype, "set");
const result = await service.delete("1");
expect(StorageService.prototype.get).toHaveBeenCalled();
expect(StorageService.prototype.set).toHaveBeenCalled();
expect(result).toEqual([]);
```

### Test inyectando un mock

Una alternativa más de acuerdo con Angular es acceder a la instancia en lugar de al prototipo, a traves de la inyección del servicio y de un mock del StorageService, del que depende

Para crear el mock podríamos declarar un objeto con la estructura adecuada y luego inyectarlo en el TetBed

```ts
const storageServiceMock: StorageService<Course[]> = {
  storeName: "Courses",
  storeType: "localStorage",
  storage: localStorage,
  get: () => [{} as Course],
  set: () => {},
  remove: () => {},
} as unknown as StorageService<Course[]>;

storageService = TestBed.inject(StorageService);
```

Una alternativa más simple es user el método createSpyObj de jasmine, que una vez creado el mock, lo inyectará directamente en el TestBed

```ts
  beforeEach(() => {
    storageServiceMock = jasmine.createSpyObj(
      'StorageService',
      {
        get: [{}],
        set: undefined,
        remove: undefined,
      },
      [
        {
          storeName: 'Courses',
          storeType: 'localStorage',
          storage: localStorage,
        },
      ],
    );

```

En cualquiera de los dos casos, el TestBed se convierte en provider del mock de StorageService (la dependencia del servicio a testar), y del token con sus parámetros

```ts
TestBed.configureTestingModule({
  providers: [
    { provide: "storeName", useValue: "Courses" },
    {
      provide: StorageService,
      useValue: storageServiceMock,
    },
  ],
});
```

El resto de los tests son prácticamente iguales pero espiando los servicios del mock en lugar de los del prototipo. Por ejemplo en el caso de add

```ts
(storageServiceMock.get as jasmine.Spy).and.returnValue([{ id: "1", isComplete: false } as Course]);
const result = await service.add({ id: "2", isComplete: false });
expect(storageServiceMock.get).toHaveBeenCalled();
expect(storageServiceMock.set).toHaveBeenCalled();
expect(result).toEqual([{ id: "1", isComplete: false } as Course, { id: "2", isComplete: false } as Course]);
```

### Test del componente CoursesList, que utiliza el servicio LocalRepo

Por un lado vamos a añadir los test del repo CoursesInMemoryRepoService que antes estaba testado indirectamente y ahora deja de estarlo al no ser usado por ningún componente.

Por otro vamos a cambiar el planteamiento del test del componente, que ahora utiliza un repo con persistencia, mockeando dicho repo en el test del componente, para hacerlo unitario y no depender de un servicio externo que a su vez depende de la forma en que se implemente la persistencia, en este caso a¡vía un segundo servicio.

Para realizar el mock utilizamos nuevamente el método createSpyObj de jasmine

```ts
mockRepoService = jasmine.createSpyObj<CoursesLocalRepoService>("CoursesLocalRepoService", {
  getAll: Promise.resolve([{ id: "1" } as Course]),
  add: Promise.resolve([{ id: "1" } as Course, { id: "2" } as Course]),
  update: Promise.resolve([{ id: "1", title: "Updated Title" } as Course]),
  delete: Promise.resolve([] as Course[]),
});
```

El problema es que el componente esta definido como provider de los servicios por lo que tenemos que sobre-escribirlo con el método overrideComponent del TesBed

```ts
await TestBed.configureTestingModule({
  imports: [CoursesListComponent],
})
  .overrideComponent(CoursesListComponent, {
    set: {
      providers: [{ provide: CoursesLocalRepoService, useValue: mockRepoService }],
    },
  })
  .compileComponents();
```

En cuanto a los test de las distintas funcionalidades,

- seleccionamos el componente add o card para disparar el evento de su EventEmitter con un determinado contenido
- comprobamos que se llama al método apropiado del mock del Servicio
- comprobamos que los datos del array se ajustan a lo esperado en función de lo que hemos definido que devuelve el mock

- add()

```ts
const addCourseElement: DebugElement = debugElement.query(By.css("isdi-course-add"));
addCourseElement.triggerEventHandler("addEvent", { title: "Test" });

expect(component.courses.length).toBe(1);
await fixture.whenStable();
expect(mockRepoService.add).toHaveBeenCalled();
expect(component.courses.length).toBe(2);
```

- update()

```ts
(mockRepoService.getAll as jasmine.Spy).and.resolveTo([{ id: "1" } as Course, { id: "2" } as Course]);
fixture.detectChanges();
const cardCourseElement: DebugElement[] = debugElement.queryAll(By.css("isdi-course-card"));
cardCourseElement[0].triggerEventHandler("updateEvent", {
  id: "1",
  title: "Updated Title",
} as Course);

await fixture.whenStable();
expect(mockRepoService.update).toHaveBeenCalled();
expect(component.courses[0].title).toBe("Updated Title");
```

- delete()

```ts
(mockRepoService.getAll as jasmine.Spy).and.resolveTo([{ id: "1" } as Course]);
mockRepoService.getAll();
fixture.detectChanges();
const cardCourseElement: DebugElement = debugElement.query(By.css("isdi-course-card"));
cardCourseElement.triggerEventHandler("deleteEvent", { id: "1" });

expect(component.courses.length).toBe(1);
await fixture.whenStable();
expect(mockRepoService.delete).toHaveBeenCalled();
expect(component.courses.length).toBe(0);
```

El `await fixture.whenStable()` nos permite aserciones sobre los valores antes y después de la respuesta a los eventos que disparamos.

## Servicios: LocalRepo utilizando observables

Dado que tenemos un repo al que hemos añadido el uso de promesas solo para probarlo, podemos sustituirlo por el uso de observables

### Ajustes de los tests del repo al uso de observables

Al tener observables en vez de promesas, debemos cambiar los tests correspondientes, en los que ya no tendrá sentido el async/await.
En su lugar, tendremos que suscribirnos al observable

```ts
  beforeEach(() => {
    spyOn(StorageService.prototype, 'get').and.returnValue([]);

    service.getAll().subscribe((result) => {
      expect(StorageService.prototype.get).toHaveBeenCalled();
      expect(result).toEqual([]);
    });
  });
```

### Ajustes de los tests del componente al uso de observables

De nuevo tenemos que ajustar los tests al nuevo funcionamiento del observable.
Donde antes moqueábamos el servicio con un and.resolveTo,
ahora retornaremos un observable, utilizando el operador of que ya conocemos

```ts
 mockRepoService = jasmine.createSpyObj<CoursesLocalRepoService>(
      'CoursesLocalRepoService',
      {
        getAll: of([{ id: '1' } as Course]),
        add: of([{ id: '1' } as Course, { id: '2' } as Course]),
        update: of([{ id: '1', title: 'Updated Title' } as Course]),
        delete: of([] as Course[]),
      },
    );
  ...
  (mockRepoService.getAll as jasmine.Spy).and.returnValue(
      of([{ id: '1' } as Course]),
```

## Formularios reactivos

### Test de los formularios Data-Driven (Login y Register)

En los test de los formularios reactivos, por ejemplo en el Login:

- completamos los valores de los inputs
- lanzamos el evento submit del formulario

```ts
  const inputs = fixture.debugElement.queryAll(By.css('input'));
  inputs[0].nativeElement.value = 'sample@acme.com';
  inputs[1].nativeElement.value = '123456';
  inputs[0].nativeElement.dispatchEvent(new Event('input'));
  inputs[1].nativeElement.dispatchEvent(new Event('input'));
  fixture.detectChanges();
  const form = fixture.debugElement.query(By.css('form'))
    .nativeElement as HTMLFormElement;
  form.dispatchEvent(new Event('submit'));
```

- comprobamos que el formulario es válido
- comprobamos que el formGroup.value refleja los valores de los inputs
- comprobamos que se ejecuta el método correspondiente del componente

```ts
  expect(component.formGroup.valid).toBeTruthy();
  expect(component.formGroup.value).toEqual({
    email: 'sample@acme.com',
    passwd: '123456',
  });
  expect(component.onSubmit).toHaveBeenCalled();
  expect(mockUsersStoreService.login).toHaveBeenCalledWith({
    email: 'sample@acme.com',
    passwd: '123456',
  });
```

En un segundo caso, lanzamos el evento submit del formulario con valores inválidos y comprobamos que el formulario es inválido y que se ejecuta el método submit pero no la llamada al servicio

```ts
      expect(component.formGroup.invalid).toBeTruthy();
      expect(component.onSubmit).toHaveBeenCalled();
      expect(mockUsersStoreService.login).not.toHaveBeenCalled();
    });
```

En el formulario Register el procedimiento será similar, pero con más campos a los que asignar valores.

## HttpClient

### Test del servicio con HttpClient

Para los test del servicio que encapsula httpClient, Angular proporciona una serie de herramientas
que importaremos desde **'@angular/common/http/testing'**

- HttpClientTestingModule
- HttpTestingController
- TestRequest

El módulo HttpClientTestingModule se importa en el test para que funcione como provider

```ts
TestBed.configureTestingModule({
  imports: [HttpClientTestingModule],
});
```

El controller es la instancia de HttpTestingController que hará de mock de fetch para crear la request http

```ts
 let controller: HttpTestingController;
 ...
 controller = TestBed.inject(HttpTestingController)
```

Además definiremos una constante con la url que esperaríamos que usara nuestro servicio.

```ts
const expectedUrl = new URL("courses", environment.baseUrl).href;
```

En el test de un método que use httpClient

- nos suscribimos al método, incluyendo los asserts en la suscripción

- creamos la request http simulada

```ts
const testRequest: TestRequest = controller.expectOne(expectedUrl);
expect(testRequest.request.method).toEqual("GET");
```

- lanzamos la request definiendo la response moqueada que queremos que le llegue a la suscripción

```ts
testRequest.flush([]);
```

Por ejemplo, para el método getAll

```ts
service.getAll().subscribe((courses) => {
  expect(courses).toEqual([]);
});

const testRequest: TestRequest = controller.expectOne(expectedUrl);
expect(testRequest.request.method).toEqual("GET");

testRequest.flush([]);
```

En el caso del método add, además de los asserts de la suscripción, habrá que comprobar que la request lleva el body que esperamos

```ts
service.add({ id: "1" }).subscribe(([course]) => {
  expect(course).toEqual({ id: "1" } as Course);
});

const testRequest: TestRequest = controller.expectOne(expectedUrl);
expect(testRequest.request.method).toEqual("POST");
expect(testRequest.request.body).toEqual({ id: "1" });

testRequest.flush({ id: "1" });
```

En el caso del método update, además de los asserts de la suscripción, habrá que comprobar que la request lleva el body que esperamos y la url que esperamos

```ts
service.update("1", { id: "1" }).subscribe(([course]) => {
  expect(course).toEqual({ id: "1" } as Course);
});

const testRequest: TestRequest = controller.expectOne(expectedUrl + "/1");
expect(testRequest.request.method).toEqual("PATCH");
expect(testRequest.request.body).toEqual({ id: "1" });

testRequest.flush({ id: "1" });
```

En el caso del método delete, además de los asserts de la suscripción, habrá que comprobar que la request lleva la url que esperamos

```ts
service.delete("1").subscribe(([course]) => {
  expect(course).toEqual({ id: "1" } as Course);
});

const testRequest: TestRequest = controller.expectOne(expectedUrl + "/1");
expect(testRequest.request.method).toEqual("DELETE");

testRequest.flush({ id: "1" });
```

### Ajustes en los tests de componentes al usar HttpClient en sus servicios

En el componente **CoursesList** y en la página que lo consume, **Course**, tiene que haber un provider del servicio nativo HttpClient,
para que no de un error NullInjector al haber intentado el inyector conseguir una instancia del servicio para poder inyectarlo.

Lo indicaremos el los entornos de sus tests

```ts
  await TestBed.configureTestingModule({
    ...
    providers: [provideHttpClient()],
  }).compileComponents();
```

En Course además moquearemos el método getAll, para evitar que el componente CoursesList, al llamar a getAll en el OnInit use el servicio HttpCliente real

```ts
service = TestBed.inject(CoursesApiRepoService);
spyOn(service, "getAll").and.returnValue(of([]));
```

Además habrá que hacer ajustes en los tests de CoursesList

- sustituyendo la inyección del local.repo por el api.repo
- sustituyendo los espías del repo por mocks que impidan llamada el servicio HttpCliente real.

```ts
  const mockCourses = [{ id: '1' } as Course, { id: '2' } as Course];
  beforeEach(async () => {
    ...
    service = TestBed.inject(CoursesApiRepoService);
    // Moqueamos la respuesta al ngOnInit
    spyOn(service, 'getAll').and.returnValue(of(mockCourses));
    ...
  });
```

Por ejemplo en el método add

```ts
spyOn(service, "add").and.returnValue(of([{ id: "3" } as unknown as Course]));
const addCourseElement: DebugElement = debugElement.query(By.css("isdi-course-add"));
addCourseElement.triggerEventHandler("addEvent", "any value");

expect(service.add).toHaveBeenCalled();
expect(component.courses).toEqual([{ id: "3" } as Course]);
```

En el método update

```ts
spyOn(service, "update").and.returnValue(of([{ id: "1", title: "Updated Course" } as Course]));
const updateCourseElement: DebugElement = debugElement.query(By.css("isdi-course-update"));
updateCourseElement.triggerEventHandler("updateEvent", { id: "1" });

expect(service.update).toHaveBeenCalled();
expect(component.courses[0].title).toBe("Updated Course");
```

En el método delete

```ts
spyOn(service, "delete").and.returnValue(of([{ id: "1" } as unknown as Course]));
const deleteCourseElement: DebugElement = debugElement.query(By.css("isdi-course-delete"));
deleteCourseElement.triggerEventHandler("deleteEvent", { id: "1" });

expect(service.delete).toHaveBeenCalled();
expect(component.courses).toEqual(mockCourses.slice(1));
```

## Gestión de Estados: Flux

### Test del servicio con estado

El método getState se testa suscribiéndose al resultado de ejecutarlo y comprobando que se reciben las valores iniciales de las propiedades del estado definidos en el servicio (initialState)

```ts
  const result = service.getState();
  result.data.subscribe((data) => expect(data).toEqual([]));
  result.errors.subscribe((errors) => expect(errors).toEqual({}));
```

Los métodos que gestionan el estado se testan

- moqueando el método del repo implicado de modo que devuelva datos
- ejecutando el método que queremos testar
- accediendo al estado mediante getState pasa suscribirnos a los datos
- comprobando en la suscripción que los datos recibidos son los que proporciono el mock del repo

```ts
  const mockTasks = [{ id: '1' }] as unknown as Task[];
  spyOn(TasksApiRepoService.prototype, 'getAll').and.returnValue(
    of(mockTasks)
  );
  service.loadTasks();
  service.getState().data.subscribe((data) => {
    expect(data).toEqual(mockTasks);
  });
```

En los casos de error el test es similar

- el método moqueado del repo lanza un error
- nos suscribimos a los errores

```ts
  const mockErrorMessage = 'Test error';
  spyOn(TasksApiRepoService.prototype, 'getAll').and.returnValue(
    throwError(() => new Error(mockErrorMessage))
  );
  service.loadTasks();
  service.getState().errors.subscribe((errors) => {
    expect(errors.load).toEqual(mockErrorMessage);
  });
```

Para los métodos que modifican el estado, update y delete, el test es similar, pero al inicio también mockeamos y ejecutamos el método getAll para que el estado tenga los datos iniciales que nos interesan para el test

```ts
  const mockTasks = [{ id: '1' }, { id: '2' }] as unknown as Task[];
  const updatedTask = { id: '1', title: 'Updated' } as unknown as Task;
  spyOn(TasksApiRepoService.prototype, 'getAll').and.returnValue(
    of(mockTasks),
  );
  spyOn(TasksApiRepoService.prototype, 'update').and.returnValue(
    of([updatedTask]),
  );
  ...
```

### Test de los componentes que utilizan el servicio

El test de TaskList, se reduce al mínimo al haber desaparecido los métodos que gestionaban los eventos emitidos por los hijos.

El test se limita a comprobar que al crear el componente, es llamado el método load tasks del servicio Store

```ts
  let service: TasksStoreService;
  ...
  providers: [TasksStoreService, provideHttpClient()],
  ...
  service = TestBed.inject(TasksStoreService);
  spyOn(service, 'loadTasks');
  ...
  expect(service.loadTasks).toHaveBeenCalled();
  ...
```

El test de TaskAdd, en lugar de espiar al EventEmitter del componente
ahora espía un método del servicioStore, en este caso addTask.
Donde antes era llamado el primero, ahora lo es el segundo.

```ts
  spyOn(service, 'addTask');
  expect(service.addTask).toHaveBeenCalledWith(mockTaskData);
```

Lo mismo sucede en los tests de TaskCard

### Test del interceptor de errores

Para testarlo de forma unitaria, tenemos que ejecutarlo pasándole los parámetros adecuados:

- la función next moqueada, utilizando **jasmine.createSpy()** [el equivalente a jest.fn()] para que lance una httpErrorResponse con código 0 o distinto de 0
- la request, real o moqueada con **jasmine.createSpyObj()**

```ts
  const httpErrorResponse = new HttpErrorResponse({ status: 0 [400]});
  const nextMock: HttpHandlerFn = jasmine
    .createSpy()
    .and.returnValue(throwError(() => httpErrorResponse));

  // const requestMock = new HttpRequest('GET', '/test'); ====> objeto real
  const requestMock = jasmine.createSpyObj('HttpRequest', [
    'doesNotMatter',
  ]);
```

Una vez ejecutado el interceptor, no suscribimos para hacer el assert en el handle del error, esperando un mensaje de error u otro

```ts
  interceptor(requestMock, nextMock).subscribe({
    // En un caso
    error: (error: Error) => expect(error.message).toContain('interno'),
    // En el otro caso
    error: (error: Error) => expect(error.message).toContain('Backend'),
  });
```

## Signals

### Test del servicio con estado basado en signals

El tes de este servicio es similar al que hicimos cuando se basaba en observables: 

- donde antes nos suscribíamos para plantear una expectativa con los datos emitidos
- ahora lo hacemos sobre la signal correspondiente después de ejecutarla para obtener su valor

Repetimos los tests que hicimos para el servicio con estado basado en observables, para cada uno de los métodos del servicio

- getState
- setNoErrors
- loadTasks
- addTask
- updateTask
- deleteTask

En el primer caso, **getState**, esperamos que la signal devuelva el estado inicial

```ts
  const result = service.getState();
  expect(result.data()).toEqual([]);
  expect(result.errors()).toEqual({});
```

Lo mismo sucede en el caso de **setNoErrors**, donde esperamos que la signal devuelva el estado inicial en cuanto a errores

```ts
  service.setNoErrors();
  const result = service.getState();
  expect(result.errors()).toEqual({});
```

En el caso de **loadTasks**, moquearemos el servicio getAll del repo y esperamos que la signal devuelva el estado con los datos devueltos por dicho servicio

```ts
  const mockTasks = [{ id: 1 }] as unknown as Task[];
  spyOn(TasksApiRepoService.prototype, 'getAll').and.returnValue(
    of(mockTasks),
  );

  service.loadTasks();
  const result = service.getState();
  expect(result.data()).toEqual(mockTasks);
```

Para este mismo método, moquearemos que el servicio getAll del repo devuelva un error, y esperamos que la signal del error devuelva el error correspondiente

```ts
  const mockErrorMessage = 'Test error';
  spyOn(TasksApiRepoService.prototype, 'getAll').and.returnValue(
    throwError(() => new Error(mockErrorMessage)),
  );

  service.loadTasks();
  const result = service.getState();
  expect(result.errors()).toEqual({ load: mockErrorMessage });
```

Para los métodos restantes, necesitamos setear el valor inicial del estados, para lo que moquearemos el método getAll del repo y lo ejecutaremos. 

```ts
  const mockTasks =[{ id: '1' }, { id: '2' }] as unknown as Task[];
  spyOn(TasksApiRepoService.prototype, 'getAll').and.returnValue(
    of(mockTasks),
  );
  service.loadTasks();
```

A partir de ahí, moquearemos también el método del repo implicado en cada caso y ejecutaremos el método del servicio que queremos testar

Por ejemplo para el método **addTask**

```ts
  const mockAddTask = [{ id: 1 } as unknown as Task];
  spyOn(TasksApiRepoService.prototype, 'add').and.returnValue(
          of(mockAddTask),
        );
  service.addTask(mockTaskData);
  const result = service.getState();
  expect(result.data()).toEqual([...mockTasks, ...mockAddTask]);
```

En el caso del error, como en los anteriores, moquearemos que el servicio add del repo devuelva un error, y esperamos que la signal del error devuelva el error correspondiente

```ts
  const mockErrorMessage = 'Test error';
  spyOn(TasksApiRepoService.prototype, 'add').and.returnValue(
    throwError(() => new Error(mockErrorMessage)),
  );
  service.addTask({} as TaskData);
  expect(service.getState().errors().add).toEqual(mockErrorMessage);
```

De forma similar testaremos los métodos **updateTask** y **deleteTask**

### Tests de los componentes que usan el servicio basado en signals

Los tests de los componentes que usan el servicio con estado basado en signals son idénticos a los que hicimos para los componentes que usaban el servicio con estado basado en observables, sin que influya el hecho de que ahora el estado se obtiene de una signal en lugar de un observable

Lo que testamos es que los métodos del servicio son llamados en respuesta a los eventos en los componentes

- en el caso de **SignalsList**, que el método loadTasks es llamado en el ngOnInit
- en el caso de **SignalsCard**, que los método updateTask y deleteTask son llamados en respuesta a los correspondientes eventos click
- en el caso de **SignalsAdd**, que el método addTask es llamado en respuesta al evento submit del formulario
